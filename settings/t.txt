static const float64 fTimeout = 10.0; //Seconds//
    EnterCriticalSection(&csDataAcquisition);
    /** Проверка и установка флага сбоя **/
    if(bfResetError == TRUE)
    {
        fbError = FALSE;
        LeaveCriticalSection(&csDataAcquisition);
        return 1;
    }
    if(fbError == TRUE)
    {
        LeaveCriticalSection(&csDataAcquisition);
        return -1;
    }
    /** Подготовка */
    TaskHandle hTask;
    UINT32 uSamples = dRate*uMesureTime;
    float64* Data = new float64[uSamples];
    int32 iRead = 0;
    stringstream buff;
    DAQmxCreateTask("ReadAnalog64Task", &hTask);
    buff << "/Dev" << uDev << "/ai" << uAIPort;
    float64 dVoltRange = 10.0;
    switch(uRange)
    {
        case 0: dVoltRange = 10.0;    break;
        case 1: dVoltRange = 5.0;     break;
        case 2: dVoltRange = 0.5;   break;
        case 3: dVoltRange = 0.05;  break;
    }
    DAQmxCreateAIVoltageChan(hTask, buff.str().data(), "ReadAnalog64Channel", DAQmx_Val_RSE, -dVoltRange, dVoltRange, DAQmx_Val_Volts, NULL);
    DAQmxCfgSampClkTiming(hTask, "", dRate, DAQmx_Val_Rising, DAQmx_Val_FiniteSamps, uSamples);
    if(iTrigPort > -1)
    {
        /** Параметры триггера **/
        buff.str("");
        buff << "/Dev" << uDev << "/PFI" << iTrigPort;
        DAQmxCfgDigEdgeStartTrig(hTask, buff.str().data(), iTrigEdge);
        if(dGate != 0.0)
        {
            DAQmxSetStartTrigDelayUnits(hTask, DAQmx_Val_Seconds);
            DAQmxSetStartTrigDelay(hTask, dGate);
        }
    }
    if(DAQmxFailed(DAQmxReadAnalogF64(hTask, DAQmx_Val_Auto, fTimeout, DAQmx_Val_GroupByChannel , Data, uSamples, &iRead, NULL)))
    {
        /** Что-то пошло не по плану **/
        fbError = true;
        INT32 iBufferSize = DAQmxGetExtendedErrorInfo(NULL, 0);
        char *cstrBuffer = new char[iBufferSize];
        DAQmxGetExtendedErrorInfo(cstrBuffer, iBufferSize);
        MessageBox(0, cstrBuffer, "NIDAQ error", 0);
        DAQmxClearTask(hTask);
        delete[]cstrBuffer;
        delete[] Data;
        LeaveCriticalSection(&csDataAcquisition);
        return -1;
    }
    /** Все идет по плану **/
    LeaveCriticalSection(&csDataAcquisition);
    vector<double>().swap(*vData);
    for(int32 i = 0; i < iRead; i++)
        vData->push_back(Data[i]);
    DAQmxClearTask(hTask);
    delete[] Data;