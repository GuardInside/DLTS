#include <GPIB.h>

GENERATOR Generator;

void GENERATOR::Apply()
{
    static const double K = 2.3;
    stringstream Buff;
    rewrite(Buff) << ":OUTPUT" << channel << " OFF";
        Write(Buff);
    /* Временные настройки. Время в мс */
    rewrite(Buff) << ":PULSE:PER " << period*1000000 << "NS";
        Write(Buff);
    rewrite(Buff) << ":PULSE:WIDTH " << width*1000000 << "NS";
        Write(Buff);
    /* Настройки, скрытые от пользователя */
    rewrite(Buff) << ":OUTP1:IMP 50OHM";
        Write(Buff);
    rewrite(Buff) << ":OUTP1:IMP:EXT 1000000OHM";
        Write(Buff);
    rewrite(Buff) << ":PULS:DOUB" << channel << " OFF";
        Write(Buff);
    rewrite(Buff) << ":PULS:TRIG1:VOLT TTL";
        Write(Buff);
    /* Настройки напряжения */
    rewrite(Buff) << ":HOLD VOLT";
        Write(Buff);
    if(index_mode == DLTS)
        rewrite(Buff) << ":VOLT1:HIGH " << (voltage_up)/(K) << "V";
    else if(index_mode == ITS)
        rewrite(Buff) << ":VOLT1:HIGH " << (begin_voltage)/(K) << "V";
    Write(Buff);
    rewrite(Buff) << ":HOLD VOLT";
        Write(Buff);
    rewrite(Buff) << ":VOLT1:LOW " << voltage_low/(K) << "V";
        Write(Buff);
    rewrite(Buff) << ":OUTPUT" << channel << " ON";
        Write(Buff);
}

/* Измерить параметры импульса */
void GENERATOR::mesure_pulse()
{
    gVector vData;
    EnterCriticalSection(&csDataAcquisition);
    DAQmxReadAnalog(id_DAQ, ai_port_pulse, pfi_ttl_port,
                rate_DAQ, gate_DAQ, DAQmx_Val_Rising, index_range, measure_time_DAQ,
                &vData);
    LeaveCriticalSection(&csDataAcquisition);
    /* Рассчитываем истинные значения амплитуд */
    double High = 0.0, Low = 0.0;
    double N = rate_DAQ/1000.0*Generator.period, /* Число сэмплов */
        SSW = rate_DAQ/1000.0*Generator.width/4; /* Четверть импульса в сэмплах*/
    /* Пробегаем по точка до импульса */
    for(int i = 0; i < N/2-SSW; i++)
        High += vData[i];
    /* Пробегаем по точка после импульса */
    for(int i = N/2+4*SSW+SSW; i < N; i++)
        High += vData[i];
    High /= N/2-SSW + (N - (N/2+4*SSW+SSW));
    /* Пробегаем по точка соответствующим импульсу */
    for(int i = N/2+SSW; i < N/2+3*SSW; i++)
        Low += vData[i];
    Low /= 2*SSW;
    voltage_low_measured = Low;
    voltage_up_measured = Heig
    stringstream buff;
    buff << setprecision(3) << "[" << Low << "," << High << "]";
    gAdditionalInfo(hGraph_DAQ, buff.str());
    
    
    const int FREQUENCY = 100000;
    std::vector<double> yAxis;
    DAQPulseVoltageInst.InitSession(id_DAQ, 0, FREQUENCY, period, true, 0, DAQmx_Val_Falling);
    int32 read = 0; /* Считыно точек по факту */
    DAQPulseVoltageInst.ReadAnalog(yAxis, &read);
    /* Рассчитываем истинные значения амплитуд */
    double N = FREQUENCY/1000.0*period, /* Число сэмплов */
        //SSW = FREQUENCY/1000.0*width/4; /* Четверть импульса в сэмплах*/
    /* Пробегаем по точка до импульса */
    for(int i = 0; i < N/2-SSW; i++)
        //voltage_up_measured += yAxis[i];
    /* Пробегаем по точка после импульса */
    for(int i = N/2+4*SSW+SSW; i < N; i++)
        //voltage_up_measured += yAxis[i];
    voltage_up_measured /= N/2-SSW + (N - (N/2+4*SSW+SSW));
    /* Пробегаем по точка соответствующим импульсу */
    for(int i = N/2+SSW; i < N/2+3*SSW; i++)
        //voltage_low_measured += yAxis[i];
    voltage_low_measured /= 2*SSW;
}
