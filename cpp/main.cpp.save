#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <vector>
#include <string>
#include <iomanip>
#include <sstream>
#include <stdexcept>
#include <process.h>
#include "gwin.h"
#include "variable.h"
#include "resource.h"
#include "winfunc.h"
#include "vi.h"
#include "daq.h"
#include "facility.h"
#include "dlts_math.h"

using namespace std;
using namespace gwin;
BOOL MainWindow_OnCreate(HWND, LPCREATESTRUCT);
VOID MainWindow_OnCommand(HWND, int, HWND, UINT);
VOID MainWindow_OnTimer(HWND, UINT);

/* Считываени данных с LakeShore и обновление информации */
UINT CALLBACK Thermostat_Process(void*);
UINT CALLBACK DataAcquisition_Process(void*);
UINT CALLBACK ReadAverDAQ(void*);

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow)
{
        hInst = hInstance;
        MSG messages;
        /* Регистрируем классы окон */
        CreateClass(hInst, "main window class", mwwin_proc);
        CreateClass(hInst, "main settings window class", stwin_proc);
        CreateClass(hInst, "dialog window class", dlwin_proc);
        /* Считываем все настройки из setting-файла */
        read_settings();
        /* Инициализируем объекты-инструменты             */
        /* и применяем настройки к физическим устройствам */
        ApplySettings();
        /* Инициализируем объекты ядра */
        InitializeCriticalSection(&csDataAcquisition);
        InitializeCriticalSection(&csGlobalVariable);
        /* Подгружаем динамические библиотеки */
        InitCommonControls();
        /* Создаем окно и переходим в цикл обработки сообщений */
        hMainWindow = CreateDialog(hInstance, MAKEINTRESOURCE(ID_MAIN_WINDOW), 0, nullptr);

        while (GetMessage (&messages, NULL, 0, 0))
        {
            TranslateMessage(&messages);
            DispatchMessage(&messages);
        }
        return 0;
}

//Оконная функция основного диалогового окна
LRESULT CALLBACK mwwin_proc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        HANDLE_MSG(hwnd, WM_CREATE, MainWindow_OnCreate);
        HANDLE_MSG(hwnd, WM_COMMAND, MainWindow_OnCommand);
        HANDLE_MSG(hwnd, WM_TIMER, MainWindow_OnTimer);
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc (hwnd, message, wParam, lParam);
    }
    return 0;
}

BOOL MainWindow_OnCreate(HWND hwnd, LPCREATESTRUCT)
{
    /* Дочернии окна */
    hGraph = gCreateWindow(hInst, hwnd, WS_CHILD|WS_DLGFRAME|WS_VISIBLE);
    gPosition(hGraph, 10, 22);
    gSize(hGraph, 399, 276);
    gPrecision(hGraph, 0, 2);
    gDefaultPlot(hGraph, "\0");
    hGraph_DAQ = gCreateWindow(hInst, hwnd, WS_CHILD|WS_DLGFRAME|WS_VISIBLE);
    gPosition(hGraph_DAQ, 422, 22);
    gSize(hGraph_DAQ, 399, 276);
    gPrecision(hGraph_DAQ, 0, 3);
    gDefaultPlot(hGraph_DAQ, "\0");
    hRelax = gCreateWindow(hInst, hwnd, WS_CHILD|WS_DLGFRAME|WS_VISIBLE);
    gPosition(hRelax, 10, 323);
    gSize(hRelax, 399, 276);
    gPrecision(hRelax, 0, 3);
    gDefaultPlot(hRelax, "\0");
    hGraph_DLTS = gCreateWindow(hInst, hwnd, WS_CHILD|WS_DLGFRAME|WS_VISIBLE);
    gPosition(hGraph_DLTS, 422, 323);
    gSize(hGraph_DLTS, 399, 276);
    gPrecision(hGraph_DLTS, 2, 3);
    gDefaultPlot(hGraph_DLTS, "\0");
    /* Индикатор выполнения */
    hProgress = CreateWindow(PROGRESS_CLASS, NULL, WS_VISIBLE | WS_CHILD, 850, 195, 140, 20, hwnd, (HMENU)ID_PROGRESS, hInst, NULL);
        SendMessage(hProgress, PBM_SETRANGE, 0, 100 << 16);
        SendMessage(hProgress, PBM_SETPOS, 0, 0);
    /* Таймеры */
    SetTimer(hwnd, MAIN_TIMER, REFRESH_TIME, NULL);
    SetTimer(hwnd, DAQ_TIMER, REFRESH_TIME, NULL);
    SetTimer(hwnd, THERMOSTAT_TIMER, REFRESH_TIME, NULL);
    return TRUE;
}

void MainWindow_OnCommand(HWND hwnd, int id, HWND, UINT)
{
    static HANDLE thDownload = nullptr, /* Описатель потока для загрузки */
           thSave = nullptr,            /* Описатель потока для сохранения */
           thSettings = nullptr,
           thStartWnd = nullptr;        /* Описатель потока для окна настроек */
    switch(id)
    {
        case ID_BUTTON_PREVIOUS_AI_PORT:
            if(offset_ai_port == 0 || !bfDAQ0k)
                break;
            offset_ai_port--;
            break;
        case ID_BUTTON_NEXT_AI_PORT:
            if(offset_ai_port == 1 || !bfDAQ0k)
                break;
            offset_ai_port++;
            break;
        case ID_BUTTON_PREVIOUS_DLTS:
            if(index_plot_DLTS == 0)
                break;
            index_plot_DLTS--;
            PlotDLTS();
            break;
        case ID_BUTTON_NEXT_DLTS:
            if(index_plot_DLTS == 1)
                break;
            index_plot_DLTS++;
            PlotDLTS();
            break;
        /* Переключение отображаемых в окне релаксаций */
        case ID_BUTTON_PREVIOUS_RELAXATION:
            if(index_relax == 0 || SavedRelaxations.empty())
                break;
            index_relax--;
            PlotRelax();
            break;
        case ID_BUTTON_NEXT_RELAXATION:
            if(index_relax == SavedRelaxations.size()-1 || SavedRelaxations.empty())
                break;
            index_relax++;
            PlotRelax();
            break;
        /* Сохранить файл */
        case ID_BUTTON_SAVE:
        if(thSave == nullptr || WaitForSingleObject(thSave, 0) == WAIT_OBJECT_0)
                thSave = (HANDLE)_beginthreadex(nullptr, 0, SaveFile, 0, 0, nullptr);
            break;
        /* Загрузить файл */
        case ID_BUTTON_LOAD:
            if(thDownload == nullptr || WaitForSingleObject(thDownload, 0) == WAIT_OBJECT_0)
                thDownload = (HANDLE)_beginthreadex(nullptr, 0, DownloadFile, 0, 0, nullptr);
            break;
        /* Настройки */
        case ID_BUTTON_SETTINGS:
            thCreateWindow(thSettings, ID_SETTINGS_WINDOW);
            break;
        case ID_CHECKBOX_FIX_TEMPERATURE:
            {
                static bool fix_temp = false;
                stringstream buff;
                /* Активирован флаг фиксации температуры */
                if(fix_temp == false)
                {
                    double CurrentTemperature = 0.0;
                    Thermostat.Write("CDAT?");
                    Thermostat.ReadDigit(CurrentTemperature);
                    /* Установка сетпоинта для термостата как текущую температуру */
                    rewrite(buff) << "SETP " << CurrentTemperature << "K";
                    Thermostat.Write(buff);
                    /* Установка RANGE в соответствии с текущей зоной */
                    rewrite(buff) << "RANG " << Thermostat.ZoneTable.GetActuallyHeatRange();
                    Thermostat.Write(buff);
                }
                else
                {
                    /* Установка сетпоинта в соответствии с настройками */
                    rewrite(buff) << "SETP " << Thermostat.SetPoint << "K";
                    Thermostat.Write(buff);
                    /* Установка RANGE в соответствии с текущей зоной */
                    rewrite(buff) << "RANG " << Thermostat.ZoneTable.GetActuallyHeatRange();
                    Thermostat.Write(buff);
                }
                fix_temp = !fix_temp;
            }
            break;
        /* Старт/стоп */
        case ID_BUTTON_START:
            if(start == false && !Thermostat.range_is_correct())
            {
                MessageBox(hwnd, "Invalid set point or end point value.", "Warning", MB_ICONWARNING);
                break;
            }
            if(start == false)
                thCreateWindow(thStartWnd, ID_START_WINDOW);
            if(start == true)
                StartButPush(hwnd);
            break;
        /* Установка начального и конечного значений температуры */
        case ID_BUTTON_SET:
            {
                double BeginPoint = 0.0, EndPoint = 0.0;
                /* Считываем начальное значение температуры из поля ввода */
                if(EmptyEditBox(hwnd, ID_EDITCONTROL_BEGIN))
                    BeginPoint = Thermostat.SetPoint;
                else
                    BeginPoint = ApplySettingEditBox(hwnd, ID_EDITCONTROL_BEGIN);
                /* Считываем конечное значение температуры из поля ввода */
                if(EmptyEditBox(hwnd, ID_EDITCONTROL_END))
                    EndPoint = Thermostat.EndPoint;
                else
                    EndPoint = ApplySettingEditBox(hwnd, ID_EDITCONTROL_END);
                /* Проверка корректности считанных значений */
                if(EndPoint < MIN_TEMPERATURE)
                    MessageBox(hwnd, "End point should be more than 0.00 K.", "Warning", MB_ICONWARNING);
                else if(EndPoint > MAX_TEMPERATURE)
                    MessageBox(hwnd, "End point should be less than 320.00 K.", "Warning", MB_ICONWARNING);
                else if(BeginPoint < MIN_TEMPERATURE)
                    MessageBox(hwnd, "Begin point should be more than 0.00 K.", "Warning", MB_ICONWARNING);
                else if(BeginPoint > MAX_TEMPERATURE)
                    MessageBox(hwnd, "Begin point should be less than 320.00 K.", "Warning", MB_ICONWARNING);
                else
                {
                    stringstream buff;
                    buff << setprecision(2) << fixed;
                    /* В случае корректного вода обновляем информацию в окне */
                    SetDlgItemText(hwnd, ID_EDITCONTROL_BEGIN, "");
                    rewrite(buff) << "Begin point " << BeginPoint << " K";
                    SetDlgItemText(hwnd, ID_STR_BEGIN, buff.str().data());

                    SetDlgItemText(hwnd, ID_EDITCONTROL_END, "");
                    rewrite(buff) << "End point " << EndPoint << " K";
                    SetDlgItemText(hwnd, ID_STR_END, buff.str().data());
                    /* Установка значений глобальных переменных */
                    Thermostat.SetPoint = BeginPoint;
                    Thermostat.EndPoint = EndPoint;
                    break;
                }
                break;
            }
        /* Выход */
        case ID_BUTTON_EXIT:
            DestroyWindow(hwnd);
            break;
    }
}

VOID MainWindow_OnTimer(HWND hwnd, UINT id)
{
    static HANDLE thDataAcquisition, //Описатель потока для чтения с DAQ по таймеру
            thThermostatAcquisition; //Описатель потока для чтения с термостата по таймеру
    switch(id)
    {
        case MAIN_TIMER:
            if(start)
            {
                stringstream buff;
                buff << setprecision(2) << fixed;
                double Dispersion = 0.0, Mean = 0.0;
                if((index_mode == DLTS && endofdlts == true) ||
                   (index_mode == ITS && endofits == true))
                StartButPush(hwnd);
                //Проверить стабилизацию и запустить второй поток для считывания данных
                else if(stability == false)
                {
                    /* Рассчитываем Mean-square error */
                    Dispersion = AverSqFluct(Temperature);
                    /* Проверяем условие стабилизации первое */
                    if(Dispersion <= Thermostat.TempDisp)
                    {
                        Mean = mean(Temperature);
                        /* Проверяем условие стабилизации первое второе */
                        if(fabs(Mean - Thermostat.SetPoint) <= Thermostat.TempDisp)
                        {
                            stability = true;
                            HANDLE hThread = (HANDLE)_beginthreadex(nullptr, 0, ReadAverDAQ, &Mean, 0, nullptr);
                            CloseHandle(hThread);
                        }
                    }
                }
            }
            break;
        case DAQ_TIMER:
            if(bfDAQ0k)
            {
                if(thDataAcquisition == nullptr || WaitForSingleObject(thDataAcquisition, 0) == WAIT_OBJECT_0)
                {
                    CloseHandle(thDataAcquisition);
                    thDataAcquisition = (HANDLE)_beginthreadex(nullptr, 0, DataAcquisition_Process, 0, 0, nullptr);
                }
            }
            else gDefaultPlot(hGraph_DAQ, "The NIDAQ isn't being initialized.\nYou should change advanced settings.");
            break;
        case THERMOSTAT_TIMER:
            #ifndef TEST_MODE
            if(fbThermostat0k)
            {
                #endif // TEST_MODE
                if(thThermostatAcquisition == nullptr || WaitForSingleObject(thThermostatAcquisition, 0) == WAIT_OBJECT_0)
                {
                    CloseHandle(thThermostatAcquisition);
                    thThermostatAcquisition = (HANDLE)_beginthreadex(nullptr, 0, Thermostat_Process, 0, 0, nullptr);
                }
            #ifndef TEST_MODE
            }
            else gDefaultPlot(hGraph_DAQ, "The thermostat LakeShore isn't being initialized.\nYou should change advanced settings.");
                #endif // TEST_MODE
            break;
    }
}

/* Считываем данные с аналогового входа */
UINT CALLBACK DataAcquisition_Process(void*)
{

    if(ai_port+offset_ai_port == ai_port_pulse)
    {
        double dMinVoltage = 0.0, dMaxVoltage = 0.0;
        MeasurePulse(&SignalDAQ, &dMinVoltage, &dMaxVoltage);
        stringstream buff;
        buff << setprecision(3) << "[" << dMinVoltage << "," << dMaxVoltage << "]";
        gAdditionalInfo(hGraph_DAQ, buff.str());
    }
    else
    {
        MyDAQMeasure(&SignalDAQ, 1, measure_time_DAQ*0.001, ai_port);
        gAdditionalInfo(hGraph_DAQ, "\0");
    }
    plotDAQ();
    return 0;
}

/* Считываени данных с термостата и обновление информации */
UINT CALLBACK Thermostat_Process(void*)
{
    double CurrentTemperature = 0.0, HeatPercent = 0.0, SetPoint = 0.0;
    stringstream buff;
    buff << setprecision(2) << fixed;
    /* Получаем значение текущей температуры */
    Thermostat.Write("CDAT?");
    Thermostat.ReadDigit(CurrentTemperature);
    #ifdef TEST_MODE
        srand(time(NULL));
        CurrentTemperature = rand()%50+10;
    #endif
    /* Сохраняем полученное значение */
    Temperature.push_back(CurrentTemperature);
    /* Удаляем старое значение */
    if(Temperature.size() > MAX_POINT_TEMP_GRAPH)
        Temperature.erase(Temperature.begin());
    /* Мощность ТЭНа в процентах */
    Thermostat.Write("HEAT?");
    Thermostat.ReadDigit(HeatPercent);
    rewrite(buff) << "Power " << HeatPercent << "%";
    SetDlgItemText(hMainWindow, ID_STR_POWER, buff.str().data());
    /* Текущая температура */
    rewrite(buff) << "Temperature " << CurrentTemperature << " K ";
    SetDlgItemText(hMainWindow, ID_STR_CHANNEL_A, buff.str().data());
    /* Рассчитываем и выводим Mean-square error */
    rewrite(buff) << "Mean-squared error " << AverSqFluct(Temperature) << " K";
    SetDlgItemText(hMainWindow, ID_STR_DISPERSION, buff.str().data());
    /* Выводим текущее значение SetPoint */
    Thermostat.Write("SETP?");
    Thermostat.ReadDigit(SetPoint);
    rewrite(buff) << "Set point " << SetPoint << " K";
    SetDlgItemText(hMainWindow, ID_STR_SETPOINT, buff.str().data());
    /* Обновляем изображение графика */
    gVector vData1;
    for(size_t i = 0; i < Temperature.size(); i++)
        vData1.push_back(i*REFRESH_TIME*0.001);
    gBand(hGraph, 0, 50, (CurrentTemperature-5)<0?0:(CurrentTemperature-5), (CurrentTemperature+5));
    gData(hGraph, &vData1, &Temperature);
    return 0;
}

UINT CALLBACK ReadAverDAQ(void* mean_temperature)
{
    if(index_mode == DLTS && !Thermostat.range_is_correct())
    {
        endofdlts = true;
        return 0;
    }
    double MeanTemp = *((double*)mean_temperature);
    double dVoltMin = 0.0, dVoltMax = 0.0;
    double dBeginVolt = Generator.begin_voltage, dEndVolt = Generator.end_voltage;
    bool bfPointAlreadyExist = false;
    /* В случае ITS режима, цикл ниже повторяется */
    do
    {
        #ifndef TEST_MODE
        MyDAQMeasure(&Relaxation, averaging_DAQ, measure_time_DAQ*0.001, ai_port, TRUE);
        #endif // TEST_MODE
        #ifdef TEST_MODE
        Relaxation.clear();
        for(double t = 0.0; t < measure_time_DAQ*0.001; t += 1.0/rate_DAQ)
            Relaxation.push_back(exp(t*rate_DAQ*0.001));
        #endif // TEST_MODE
        //Сохраняем релаксации, чтобы иметь возможность переключаться между ними
        if(index_mode == ITS)
        {
            SavedRelaxations.push_back(Relaxation);
            index_relax = SavedRelaxations.size() - 1;
        }
        if(index_mode == DLTS)
        {
            int offset = 0;
            for(auto it = xAxisDLTS.begin(); it != xAxisDLTS.end(); it++)
            {
                if(MeanTemp > *it) offset++;
                else if(MeanTemp == *it)
                {
                    stringstream buf;
                    buf << *it;
                    MessageBox(0,buf.str().data(),"",0);
                    bfPointAlreadyExist = true;
                    break;
                }
            }
            if(!bfPointAlreadyExist)
            {
                AddPointsDLTS(MeanTemp);
                SavedRelaxations.insert(SavedRelaxations.begin()+offset, Relaxation);
                index_relax = offset;
            }
            stringstream buff;
            Thermostat.SetPoint += Thermostat.TempStep;
            buff << "Begin point " << setprecision(2) << Thermostat.SetPoint << " K";
            SetDlgItemText(hMainWindow, ID_STR_BEGIN, buff.str().data());
            rewrite(buff) << "SETP " << Thermostat.SetPoint << "K";
            Thermostat.Write(buff);
        }
        else if(index_mode == ITS)
        {
            /* Вычисляем истинные параметры заполняющего импульса */
            MeasurePulse(NULL, &dVoltMin, &dVoltMax);
            if(Generator.begin_voltage + Generator.step_voltage > Generator.end_voltage)
            {
                Generator.begin_voltage = dBeginVolt;
                Generator.end_voltage = dEndVolt;
                Generator.Apply();
                endofits = true;
                stability = false;
                break; // Выход из цикла while
            }
            Generator.begin_voltage += Generator.step_voltage;
            Generator.Apply();
            stringstream buff;
            buff << setprecision(3) << "[" << dVoltMin << "," << dVoltMax << "]";
            gAdditionalInfo(hRelax, buff.str());
        }
        if(!bfPointAlreadyExist)
        {
            SaveRelaxSignal(MeanTemp, Relaxation, dVoltMin, dVoltMax);//Сохраняем результат в файл
            PlotRelax();
            PlotDLTS();
        }
    }while(index_mode == ITS && start == true && stability == true && endofits == false);
    stability = false;
    return 0;
}
