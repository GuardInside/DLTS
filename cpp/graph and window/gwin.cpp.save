#include "gwin.h"
#define DEFAULT_HEIGHT_FONT 80
#define DEFAULT_WIDTH_FONT  20
#define DEFAULT_PRECISION   3
#define GWND_LOGICAL_SIZE   1200
#define GPLOT_LOGICAL_SIZE  1000
using namespace gwin;

namespace gwin
{
    struct gPlotInfo
    {
        ~gPlotInfo()
        {
            DeleteObject((HBITMAP)hBitMap);
            DeleteObject((HPEN)hAxisPen);
            DeleteObject((HPEN)hPlotPen);
            DeleteObject((HPEN)hGridPen);
            DeleteObject((HFONT)hTextFont);
        }
        gPlotInfo():
            hBitMap{NULL},
            iMark1{5}, iMark2{10},
            iPrec1{DEFAULT_PRECISION}, iPrec2{DEFAULT_PRECISION},
            hAxisPen{CreatePen(PS_SOLID, 0, RGB(255,255,255))},
            hPlotPen{CreatePen(PS_SOLID, 0, RGB(255,215,0))},
            hGridPen{CreatePen(PS_DOT, 0, RGB(192, 192, 192))},
            crTextColor{RGB(0,255,0)},
            hTextFont{CreateFont(DEFAULT_HEIGHT_FONT, DEFAULT_WIDTH_FONT, 0, 0, FW_NORMAL, 1, 0, 0,
                                 DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                                 PROOF_QUALITY, DEFAULT_PITCH | FF_ROMAN, "Arial")},
            bfEnableGrid{true}{}
        HBITMAP hBitMap;
        UINT iMark1, iMark2;
        INT iPrec1, iPrec2;
        HPEN hAxisPen, hPlotPen, hGridPen;
        COLORREF crTextColor;
        HFONT hTextFont;
        BOOL bfEnableGrid;
    };

    class gBuffer
    {
        public:
            std::stringstream& operator<<(double dNum)
            {
                buffer.str("");
                buffer << dNum;
                return buffer;
            }
            std::stringstream& operator<<(std::string str)
            {
                buffer.str("");
                buffer << str;
                return buffer;
            }
            std::string str()
            {
                return buffer.str();
            }
            void fixed()
            {
                buffer << std::fixed;
            }
            void scientific()
            {
                buffer << std::scientific;
            }
            void setprecision(int p)
            {
                buffer << std::setprecision(p);
            }
        private:
            std::stringstream buffer;
    };

    std::map<HWND, gPlotInfo> _gMap;

    LRESULT CALLBACK _gWinProcess (HWND, UINT, WPARAM, LPARAM);
    VOID _gOnCommand(HWND, int, HWND, UINT);
    VOID _gOnPaint(HWND hWnd);

    VOID gWindowMetric(HWND hWnd, LONG *iWidth, LONG *iHeight);
    VOID gClearBitmap(HWND hWnd);
    VOID gTransformPlot(HWND hWnd, HDC &hdc);
    BOOL gMulDrawPlot(HWND hWnd, HDC &hdc, const gVector *vData1, const gMulVector *vMulData2);
    BOOL gDrawPlot(HWND hWnd, HDC &hdc, const gVector *vData1, const gVector *vData2);
    BOOL gEmbedBitmap(HWND hWnd, HDC &hdc);
}

/* ********************** */
/*  Интерфейс библиотеки  */
/* ********************** */
HWND gwin::gCreateWindow(HINSTANCE hInst, HWND hWndParent, DWORD style)
{
    const std::string strClass = "gWinClass";
    WNDCLASS wc = {0};
    wc.lpfnWndProc = _gWinProcess;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(WHITE_BRUSH);
    wc.lpszClassName = strClass.c_str();
    RegisterClass(&wc);
    HWND hWnd = CreateWindow(strClass.c_str(), "", style, 0, 0, 100, 100, hWndParent, NULL, hInst, NULL);
    _gMap[hWnd];
    return hWnd;
}

BOOL gwin::gClose(HWND hWnd)
{
    _gMap.erase(hWnd);
    return DestroyWindow(hWnd);
}

BOOL gwin::gMulData(HWND hWnd, const gVector *vData1, const gMulVector *vMulData)
{
    /** Проверка полноты **/
    /*if(vData1->size() != vMulData->at(0).size() || vData1->empty())
        return FALSE;*/
    /** Подготовка к отрисовке **/
    LONG iWidth, iHeight;
    gWindowMetric(hWnd, &iWidth, &iHeight);
    HDC hdc = CreateCompatibleDC(GetDC(hWnd));
    HBITMAP bitPlot = CreateCompatibleBitmap(GetDC(hWnd), iWidth, iHeight);
    SelectObject(hdc, bitPlot);
    /** Отрисовка в буфере памяти **/
    PatBlt(hdc, 0, 0, iWidth, iHeight, BLACKNESS);
    gTransformPlot(hWnd, hdc);
    gMulDrawPlot(hWnd, hdc, vData1, vMulData);
    /** Конец отрисовки **/
    gClearBitmap(hWnd);
    _gMap.at(hWnd).hBitMap = bitPlot;
    DeleteDC(hdc);
    InvalidateRect(hWnd, NULL, FALSE);
    return TRUE;
}

BOOL gwin::gData(HWND hWnd, const gVector *vData1, const gVector *vData2)
{
    /** Проверка полноты **/
    /*if(vData1->size() != vData2->size() || vData1->empty())
        return FALSE;*/
    const gMulVector vMulData2{*vData2};
    return gMulData(hWnd, vData1, &vMulData2);
}

BOOL gwin::gPosition(HWND hWnd, INT x, INT y)
{
    return SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
}

BOOL gwin::gSize(HWND hWnd, INT width, INT height)
{
    return SetWindowPos(hWnd, NULL, 0, 0, width, height, SWP_NOZORDER | SWP_NOMOVE);
}

BOOL gwin::gFont(HWND hWnd, int iHeight, int iWidth, int iAngle, int iWeight, std::string strFontName)
{
    if(iWeight < 0 || iWeight > 1000) return FALSE;
    if(iWeight == 0) iWeight = FW_NORMAL;
    if(iHeight == 0) iHeight = DEFAULT_HEIGHT_FONT;
    if(iWidth  == 0) iWidth  = DEFAULT_WIDTH_FONT;
    DeleteObject((HFONT)_gMap.at(hWnd).hTextFont);
    _gMap.at(hWnd).hTextFont = CreateFont(iHeight, iWidth, 0, iAngle, iWeight, 1, 0, 0,
                             DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             PROOF_QUALITY, DEFAULT_PITCH | FF_ROMAN, strFontName.c_str());
    return TRUE;
}


/* **************************************************************** */
/* Внутренние функции библиотеки. Закрыты для общего использования. */
/* **************************************************************** */
VOID gwin::gWindowMetric(HWND hWnd, LONG *iWidth, LONG *iHeight)
{
    RECT rc;
    GetClientRect(hWnd, &rc);
    //GetWindowRect(hWnd, &rc);
    *iWidth = abs(abs(rc.right)-abs(rc.left));
    *iHeight = abs(abs(rc.top)-abs(rc.bottom));
}

VOID gwin::gClearBitmap(HWND hWnd)
{
    if(_gMap.find(hWnd) != _gMap.end())
        DeleteObject((HBITMAP)_gMap.at(hWnd).hBitMap);
}

VOID gwin::gTransformPlot(HWND hWnd, HDC &hdc)
{
    LONG iWidth, iHeight;
    gWindowMetric(hWnd, &iWidth, &iHeight);
    SetMapMode(hdc, MM_ANISOTROPIC);
    SetWindowExtEx(hdc, GWND_LOGICAL_SIZE, -GWND_LOGICAL_SIZE, NULL);
    SetViewportExtEx(hdc, iWidth, iHeight, NULL);
}

BOOL gwin::gMulDrawPlot(HWND hWnd, HDC &hdc, const gVector *vData1, const gMulVector *vMulData2)
{
    static CONST LONG iPlotSize = GPLOT_LOGICAL_SIZE; /* Размер графика в логических единицах */
    HPEN &hAxisPen = _gMap.at(hWnd).hAxisPen,
         &hPlotPen = _gMap.at(hWnd).hPlotPen,
         &hGridPen = _gMap.at(hWnd).hGridPen,
         hOldPen;
    INT iIntent = iPlotSize/100;
    UINT iMark1 = _gMap.at(hWnd).iMark1, iMark2 = _gMap.at(hWnd).iMark2; /* Число рисок */
    COLORREF OldTextColor;
    HFONT hOldFont;
    gBuffer buff;
    double  z = 0.0, hx = 0.0, hy = 0.0,
            max_y = vMulData2->at(0).at(0), min_y = vMulData2->at(0).at(0),
            max_x = vData1->at(0), min_x = vData1->at(0);
    int     x = 0, y = 0;
    size_t  i = 0;
    /* Масштабные множители */
    for(const auto &itir: *vData1)
        if(max_x < itir) max_x = itir;
        else if(min_x > itir) min_x = itir;
    for(const auto &extiter: *vMulData2)
        for(const auto &itir: extiter)
            if(max_y < itir) max_y = itir;
            else if(min_y > itir) min_y = itir;
    hx = (max_x - min_x)/iMark1;
    hy = (max_y - min_y)/iMark2;
    /* Сдвигаем начало координат */
    LONG iWidth, iHeight;
    gWindowMetric(hWnd, &iWidth, &iHeight);
    POINT pIndent = {150, 100};
    SetViewportOrgEx(hdc, pIndent.x*((double)iWidth/GWND_LOGICAL_SIZE),
                          iHeight - pIndent.y*((double)iHeight/GWND_LOGICAL_SIZE), NULL);
    /* Настройка инструментов рисования */
    hOldPen = (HPEN)SelectObject(hdc, (HPEN)hAxisPen);
    hOldFont = (HFONT)SelectObject(hdc, (HFONT)_gMap.at(hWnd).hTextFont);
    OldTextColor = SetTextColor(hdc, _gMap.at(hWnd).crTextColor);
    buff.fixed();
    SetBkMode(hdc, TRANSPARENT);
    /* Рисуем прямоугольную координатную сетку */
    for(int c = 0; c < 2; c++)
    {
        /* Размечаем масштаб оси X */
        if(c == 0) buff.setprecision(_gMap.at(hWnd).iPrec1);
        const int Y = (iPlotSize + 0.5)*c;
        MoveToEx(hdc, 0, 0+Y, NULL);
        LineTo(hdc, iPlotSize, 0+Y);
        for(z = min_x, i = 0; i <= iMark1; z += hx, i++)
        {
            x = int((z - min_x)*iPlotSize/(max_x - min_x) + 0.5);
            MoveToEx(hdc, x, -iIntent+Y, NULL);
            LineTo(hdc, x, iIntent+Y);
            if(c == 0)
            {
                buff << z;
                TextOut(hdc, x-0.5*pIndent.x, y - iIntent, buff.str().c_str(), buff.str().length());
            }
        }
        /* Размечаем масштаб оси Y */
        if(c == 0) buff.setprecision(_gMap.at(hWnd).iPrec2);
        const int X = (iPlotSize + 0.5)*c;
        MoveToEx(hdc, 0+X, iPlotSize, NULL);
        LineTo(hdc, 0+X, 0);
        for (z = min_y, i = 0; i <= iMark2; z += hy, i++)
        {
            y = int((z - min_y)*iPlotSize/(max_y - min_y) + 0.5);
            MoveToEx(hdc, -iIntent+X, y, NULL);
            LineTo(hdc, iIntent+X, y);
            if(c == 0)
            {
                buff << z;
                TextOut(hdc, -pIndent.x, y+0.5*pIndent.y, buff.str().data(), buff.str().length());
            }
        }
    }
    /* Размечаем сетку, если необходимо */
    SelectObject(hdc, (HPEN)hGridPen);
    if(_gMap.at(hWnd).bfEnableGrid)
    {
        /* Горизонтальные линии */
        for(z = min_y + hy; z < max_y; z += hy)
        {
            y = int((z - min_y)*iPlotSize/(max_y - min_y) + 0.5);
            MoveToEx(hdc, iIntent, y, NULL);
            LineTo(hdc, iPlotSize-iIntent, y);
        }
        /* Вертикальные линии */
        for(z = min_x + hx; z < max_x; z += hx)
        {
            x = int((z - min_x)*iPlotSize/(max_x - min_x) + 0.5);
            MoveToEx(hdc, x, iIntent, NULL);
            LineTo(hdc, x, iPlotSize-iIntent);
        }
    }
    /* Строим график */
    SelectObject(hdc, (HPEN)hPlotPen);
    const gVector &xAxis = *vData1;
    for(const auto &extiter: *vMulData2)
    {
        const gVector &yAxis = extiter;
        y = int((yAxis[0] - min_y)*iPlotSize/(max_y - min_y));
        MoveToEx(hdc, 0, y, NULL);
        for(i = 1; i < xAxis.size(); i++)
        {
            x = int((xAxis[i] - min_x)*iPlotSize/(max_x - min_x) + 0.5);
            y = int((yAxis[i] - min_y)*iPlotSize/(max_y - min_y) + 0.5);
            LineTo(hdc, x, y);
        }
    }
    /* Выводим дополнительную информацию */
    if(!_gMap.at(hWnd).strAdInfo.empty())
    {
        std::string strAdInfo;
        std::stringstream buff;
        buff << _gMap.at(hWnd).strAdInfo;
        int s = 0;
        int uTextHeight = 80;
        while(std::getline(buff, strAdInfo))
        {
            TextOut(hdc, iIndent, iPlotSize - s*uTextHeight, buff.str().data(), buff.str().length());
            s++;
        }
    }
    SelectObject(hdc, (HPEN)hOldPen);
    SelectObject(hdc, (HFONT)hOldFont);
    SetTextColor(hdc, OldTextColor);
    return TRUE;
}

BOOL gwin::gDrawPlot(HWND hWnd, HDC &hdc, const gVector *vData1, const gVector *vData2)
{
    const gMulVector vMulData2{*vData2};
    return gMulDrawPlot(hWnd, hdc, vData1, &vMulData2);
}

BOOL gwin::gEmbedBitmap(HWND hWnd, HDC &hdc)
{
    LONG iWidth, iHeight;
    gWindowMetric(hWnd, &iWidth, &iHeight);
    HDC memhdc;
    if(_gMap.find(hWnd) != _gMap.end())
    {
        memhdc = CreateCompatibleDC(hdc);
        SelectObject(memhdc, _gMap.at(hWnd).hBitMap);
        BitBlt(hdc, 0, 0, iWidth, iHeight, memhdc, 0, 0, SRCCOPY);
        DeleteDC(memhdc);
        return TRUE;
    }
    return FALSE;
}

/* *************** */
/* Оконная функция */
/* *************** */

LRESULT CALLBACK gwin::_gWinProcess(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        HANDLE_MSG(hWnd, WM_PAINT, _gOnPaint);
        //HANDLE_MSG(hWnd, WM_COMMAND, _gOnCommand);
        //HANDLE_MSG(hWnd, WM_TIMER, MainWindow_OnTimer);
        case WM_CREATE:

            break;
        default:
            return DefWindowProc (hWnd, message, wParam, lParam);
    }
    return 0;
}

VOID gwin::_gOnPaint(HWND hWnd)
{
    HDC hdc;
    PAINTSTRUCT ps;
    hdc = BeginPaint(hWnd, &ps);
        gEmbedBitmap(hWnd, hdc);
    EndPaint(hWnd, &ps);
}

